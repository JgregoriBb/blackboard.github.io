I"ù'<h1 id="three-legged-oauth">Three-Legged OAuth</h1>
<p><em>Author: Scott Hurrey</em><br />
<em>Categories: []</em><br />
<em>Tags: [‚Äòrest‚Äô, ‚Äòauthentication‚Äô, ‚Äòauthorization‚Äô, ‚Äò3lo‚Äô, ‚Äòthree-legged oauth‚Äô, ‚Äòdeveloper‚Äô]</em></p>
<hr />

<p>One of the drawbacks associated with <a href="Basic%20Authentication.html">Basic Authentication</a> is that the application requires broad access, as the tool
is acting as a system-level user and enacting for the user. Three-legged OAuth
(3LO) allows an application to act as a user. This sounds scary, but it
actually allows for much more granular access control. Rather than a system
user acting as someone that can modify all courses, the application is now
acting as Professor X, and as such, only has access to his or her courses.</p>

<p>As of Blackboard Learn 3200.7 (SaaS deployed release), third-party REST
applications now have the ability to implement 3LO to authorize a user against
the APIs and act as that user. In the spirit of sharing pretty pictures, here
is a nice diagram displaying the workflow:</p>

<p><img src="/images/113291.png" alt="3_legged_oauth_workflow.png" /></p>

<p>So let‚Äôs talk a bit about what is happening here. Let‚Äôs pretend that we have
built a mobile app that allows a student to get his or her grades. Today, we
will be Marlee. Marlee picks up her iPhone and opens the GetMyGrades app. The
first time Marlee opens the app, the app will send a GET request to
<code class="highlighter-rouge">/learn/api/public/v1/oauth2/authorizationcode</code> with the Content-Type set to
<code class="highlighter-rouge">form/urlencoded</code> and the following data as query parameters:</p>

<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Definition</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>redirect_uri</td>
      <td>Where to redirect the user once they have authorized the application</td>
      <td>redirect_uri=https://my.edu/authorized</td>
    </tr>
    <tr>
      <td>response_type</td>
      <td>Must be set to code. Tells the endpoint to return an authorization code</td>
      <td>response_type=code</td>
    </tr>
    <tr>
      <td>client_id</td>
      <td>The application‚Äôs OAuth <strong>key</strong>, from the <strong>key</strong>/secret pair as registered in the developer portal.<br /><strong>NOTE: This is NOT the Application ID!!</strong></td>
      <td>client_id=8DBBA050-B830-414F-B7F1-0B448A6320C9</td>
    </tr>
    <tr>
      <td>scope</td>
      <td>The application‚Äôs permissions: read, write, delete, and/or offline.<br />Offline is required to use Refresh Tokens<br /><em><strong>CAUTION</strong></em>: If you do not <strong>set the scope appropriately</strong> you will still be able to get an access_token, but when using the access_token you will not be able to GET, POST, or UPDATE as expected. Instead you will get error responses.</td>
      <td>scope=read</td>
    </tr>
    <tr>
      <td>state</td>
      <td>Opaque value used to prevent Cross Site Request Forgery</td>
      <td>state=DC1067EE-63B9-40FE-A0AD-B9AC069BF4B0</td>
    </tr>
  </tbody>
</table>

<p>So in this example, my request would look like:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /learn/api/public/v1/oauth2/authorizationcode?redirect_uri=https://my.edu/authorized&amp;response_type=code&amp;client_id=8DBBA050-B830-414F-B7F1-0B448A6320C9&amp;scope=read&amp;state=DC1067EE-63B9-40FE-A0AD-B9AC069BF4B0
</code></pre></div></div>

<p>The result of this action is that Marlee is presented with her school‚Äôs
Blackboard Learn login screen. She logs in and is presented with the following
screen, asking her to authorize the application.</p>

<p><img src="/images/113292.png" width="300" alt="Blackboard Learn three-legged oauth authorization screen shot" /></p>

<p>Once Marlee clicks ‚ÄòAllow‚Äô, the URL sent as the redirect uri is called with
the authorization code as a query parameter, for example:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://my.edu/authorized?code=1234567890
</code></pre></div></div>

<p>Now the application is able to talk server-to-server as Marlee. The next step
is to get an access token from Learn based on the authorization code Marlee
granted. From here the workflow is very similar to the Basic Authentication
method. The token is requested as a POST request from
<code class="highlighter-rouge">/learn/api/public/v1/oauth2/token</code>. This is also a <code class="highlighter-rouge">form/urlencoded</code>. The body of
the request contains the text <code class="highlighter-rouge">grant_type=authorization_code</code>, and the URL is
parameterized with the code <code class="highlighter-rouge">code=1234567890</code> and the redirect_uri
<code class="highlighter-rouge">redirect_uri=https://my.edu/app</code>. So the request looks like:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /learn/api/public/v1/oauth2/token?code=1234567890&amp;redirect_uri=https://my.edu/app
</code></pre></div></div>

<p>The endpoint responds with the standard token (access_token, expires_in, and
token_type), but also has a couple of new fields. If offline mode is granted,
a refresh_token is returned. This allows the application to get a new token on
behalf of the user, even if that user isn‚Äôt explicitly asking for it. In
addition, the scope requested in the initial request is returned, as well as
the UUID for the user in the user_id field.</p>

<p>From this point forward, the access_token is used just as it is when using
Basic Authentication, but instead of acting as the system user, it is acting
as Marlee.</p>

<h2 id="refresh-tokens">Refresh Tokens</h2>

<p>As mentioned above, one of the available scopes that an application can
request is offline. Essentially, the offline scope allows an application to
access Blackboard Learn as a user without requiring the user to login each
time. This might be especially useful in a mobile application to prevent the
unnecessary redirects each time an application is loaded. The way this works
is through the use of refresh tokens.</p>

<p>The first time a user accesses the application and the normal 3LO process
takes place. The user is redirected to Blackboard, they login and authorize,
and then the application is off an running. The difference is that a refresh
token is returned in addition to the Bearer token. From this point forward,
the third party application can automatically request a new bearer token by
sending the request with the refresh token without involving the user at all.</p>

<p>The HTTP message might look like this:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /learn/api/public/v1/oauth2/token?refresh_token=8DBBA050-B830-414F-B7F1-0B448A6320C9&amp;redirect_uri=https://my.edu/app
</code></pre></div></div>

<p>From this point forward, the access_token is used just as it is when using
Basic Authentication, but instead of acting as the system user, it is acting
as Marlee.</p>

<h2 id="use-proof-key-for-code-exchange-pkce-with-3-legged-oauth-20">Use Proof Key for Code Exchange (PKCE) with 3-Legged OAuth 2.0</h2>

<p>Starting in version 3700.4, Blackboard Learn‚Äôs 3-Legged OAuth 2.0
implementation supports the Proof Key for Code Exchange (PKCE) extension. For
more information about PKCE, see <a href="https://oauth.net/2/pkce">OAuth 2.0‚Äôs RFC 7636: Proof Key for Code Exchange</a>.</p>

<p>To implement the PKCE extension:</p>

<ol>
  <li>
    <p>Create a random string 43-128 characters long, containing only the characters A-Z, a-z, 0-9, or the following - . _ ~ (hyphen, period, underscore, and tilde). This sting will later be used as your code_verifier.</p>
  </li>
  <li>
    <p>Use the S256 hashing method to create a hash of your random string. This hash is your code_challenge. The formula for an S256 hash is based on the SHA-256, but is not exactly the same.<br />
code_challenge = BASE64URL_ENCODE( SHA256( ASCII( code_verifier )))</p>
  </li>
</ol>

<p>For more information about the S256 hashing algorithm, see <a href="https://tools.ietf.org/html/rfc7636%23section-4.2">RFC 7636 - Proof Key for Code Exchange by OAuth Public Clients</a>.</p>

<ol>
  <li>Make a request to <code class="highlighter-rouge">/learn/api/public/v1/oauth2/authorizationcode</code>, and provide a <code class="highlighter-rouge">code_challenge</code> and <code class="highlighter-rouge">code_challenge_method</code> in the query parameters. For <code class="highlighter-rouge">code_challenge_method</code>, the endpoint accepts only <code class="highlighter-rouge">S256</code>. Your request will look something like:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST learn/api/public/v1/oauth2/authorizationcode?client_id=YOUR_CLIENT_ID&amp;response_type=code&amp;redirect_url=YOUR_URL&amp;code_challenge=YOUR_CODE_CHALLENGE&amp;code_challenge_method=S256
</code></pre></div>    </div>
  </li>
  <li>Make a request for an access token, as normal. When you do, include your code_verifier as a query parameter. Your request will look like:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST learn/api/public/v1/oauth2/token?grant_type=authorization_code&amp;code=CODE_FROM_AUTH_CALL&amp;code_verifier=YOUR_CODE_VERIFIER
</code></pre></div>    </div>
  </li>
</ol>

<p>The Learn server will verify that the code_challenge and code_challenge_method
sent in the first request form a valid hash of code_verifier. This allows to
the server to verify that the client asking for the access token is the same
client that sent the authorization code request.</p>

<ol>
  <li>When you receive an access token, you can use it as you normally would to make API calls.</li>
</ol>

<h2 id="examples">Examples</h2>

<ul>
  <li><a href="REST%20Demo%20Using%20cURL.html#oauth2-three-legged---3LO">Three-legged OAuth in Curl</a></li>
  <li><a href="https://github.com/blackboard/BBDN-3LO-REST-Swift">BBDN-3LO-REST-Swift</a></li>
</ul>

:ET